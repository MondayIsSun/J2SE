package multi_thread.concurrence;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class TestInvokeAll {

	public static void main(String[] args) throws InterruptedException, ExecutionException {

		ExecutorService tPool = Executors.newFixedThreadPool(10);// 线程池
		List<Callable<Integer>> tasks = new ArrayList<Callable<Integer>>();// 任务队列

		// 往任务队列里面加入任务
		Callable<Integer> task = null;
		for (int i = 0; i < 10; i++) {
			task = new Callable<Integer>() {
				@Override
				public Integer call() throws Exception {
					int ran = new Random().nextInt(1000);
					Thread.sleep(ran);
					System.out.println(Thread.currentThread().getName() + " 休息了 " + ran);
					return ran;
				}
			};
			tasks.add(task);
		}

		long s = System.currentTimeMillis();

		// 线程池执行任务
		List<Future<Integer>> results = tPool.invokeAll(tasks);

		System.out.println("执行任务消耗了 ：" + (System.currentTimeMillis() - s) + "毫秒");

		for (int i = 0; i < results.size(); i++) {
			try {
				System.out.println(results.get(i).get());
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		// 关闭线程池
		tPool.shutdown();
	}

}
